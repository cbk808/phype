#summary Description of the Phype Project.
#labels Phase-Design

== Table of contents ==
  # [PhypeDoc]
  # The Phype Project
  # [Implementation]
  # [Testing]
  # [Conclusions]

= The Phype Project =
Phype is a virtual machine for PHP written in !JavaScript. Using the [http://jscc.jmksf.com/ JSCC] automatic parser generator, and a context free PHP grammar, we create a LALR(1) parser for PHP. This is in turn interpreted by out interpreter, which runs PHP code directly in the browser.

== First Steps ==
The first plan for Phype was, as the current version, based on !JavaScript and the PHP-extension _parsekit_. Parsekit translates PHP scripts into opcode arrays, containing ZEND opcodes. These opcode arrays were then converted to JSON objects, to enable easier access.

We had a version up and running within the first week, and was able to parse, interpret and run some of the ZEND opcodes, like echoing, assignment and declaration of variables, declaration and calling of functions.

Unfortunately, the array-form output by parsekit lacks the symbol tables internal to the ZEND-engine, but the opcodes still contain references to these tables. This resulted in some inelegant regular expressions and hacks that resulted in brittle code for examining the PHP-code.

We decided to drop this approach, and go for parsing and interpreting the PHP-code directly.

=== Parsekit ===
Our initial implementation used a lot of arrays for saving variables, functions and arrays. This implementation worked well initially, but as we got deeper and deeper into PHP, it became obvious that it was not the best way to do it.

As mentioned, parsekit outputs PHP scripts to an array of ZEND opcodes. During this output, parsekit uses a multitude of hidden variables for saving all sorts of data: function names and parameters, array indices, variables, this-calls and more. 

These hidden variables, coupled with our array implementation, meant that we ourselves had to implement a lot of hidden variables in these arrays.

=== JSCC ===
After we dropped parsekit, we looked around for another tool to help us. Here we found the JSCC Project. JSCC is a JavaScript-based parser generator, that creates a LALR(1) parser from a context-free grammar.

JSCC included an example programming language, which included a small set of opcodes and a simple grammar. We took this and altered it significantly, to create a parser that would accomodate our needs.

JSCC gives us all the benefits of a LALR(1) parser, while giving us the possibility to create a grammer that fits our implementation perfectly. This means that our implementation is tailored specifically for PHP, and that the parser runs fast, with a worst case complexity of O(n^3^).

== Planning ==
This is an overview of the goals and progress of the Phype project. These milestones were adapted from the first ZEND incarnation of the project.

At first we need to read PHP-code and parse it, then we will implement the basic PHP functionality first; such as echos and variables, and then extend the interpreter with more advanced features, such as objects and constants. Finally we would add a GC and access to library functions, to make Phype a complete PHP VM.

=== Milestones ===
Below is an itemized list, from start to end, of the project milestones.
 * Reading PHP-code within `<script>`-tags: *Done*.
 * Parsing PHP via LALR(1)-translatable grammar: *Done*.
   * We are using JSCC for translating our version of a context free PHP grammar into a PHP-parser.
   * We have found inspiration in [http://www.phpcompiler.org/doc/latest/grammar.html PHC's abstract PHP grammar] for our context free grammar.
 * Interpreting PHP:
   * Echoing: *Done*.
   * Binary and unary operations: *Partially done*.
     * Multiplication/division and adding/subtracting works with precedence.
     * Concatenation works.
   * Type handling: *Partially done*.
     * Border-line cases has not been tested. There is probably some differences in semantics in border-line cases.
   * Assigning and reading variables: *Done*.
     * Global variables can be accessed and declared.
     * Recursively defined variables ($$a) can be accessed.
   * Array declaration and access: *Partially done*.
     * Single and multi-dimensional arrays supported.
     * Looking up a character in a string using array-notation is not (yet) supported.
   * Declaring and calling functions: *Done*.
     * Functions can be declared and called.
     * Functions can be called recursively ($a()).
     * Function return halts function-execution and returns correct value.
   * Variable scope rules: *Done*.
     * Function-local variables are function-local.
   * Conditional expressions and loops: *Partially done*.
     * Boolean expression evaluation.
     * Branching.
   * Declaring and accessing objects: *In progress*.
   * Constant declaration and acces: *Pending*.
   * Requires and includes: *Pending*.
 * Garbage collection: *Pending*.
 * Library functions: *Pending*.